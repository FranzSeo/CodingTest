## 최소 신장 트리

### 1. 신장 트리란? (Spanning Tree)
* 그래프의 모든 노드가 연결되어 있으면서 트리의 속성을 만족하는 그래프

* 신장 트리의 조건
  * 본래의 그래프의 모든 노드를 포함해야 함
  * 모든 노드가 서로 연결
  * 트리의 속성을 만족시킴 (사이클이 존재하지 않음)

### 2. 최소 신장 트리 (MST : Minimum Spanning Tree)

* 가능한 Spanning Tree 중에서, 간선의 가중치 합이 최소인 Spanning Tree 를 지칭
* 모든 노드를 연결하되, 사이클이 없고, 간선의 가중치 합이 최소인 트리
* 최단경로 길찾기 문제에서 많이 사용함

### 3. 최소 신장 트리 알고리즘

* 그래프에서 최소 신장 트리를 찾을 수 있는 알고리즘
* 대표적인 알고리즘
  * Kruskal's Algorithm / Prim's Algorithm
  * 난이도가 높음 


### 4. 크루스칼 알고리즘 (Kruskal's Algorithm )

* 사이클이 생기면 파기한다!!! 간선 = 노드 - 1
* 가중치를 비용(작은) 기준으로 노드들을 연결하면서 사이클이 있을때의 간선을 파기하는 형식으로 구현

1. 모든 정점을 독립적인 집합으로 만든다.
2. 모든 간선을 비용을 기준으로 정렬하고, 비용이 작은 간선부터 양 끝의 두 정점을 비교한다.
3. 두 정점의 최상위 정점을 확인하고, 서로 다를 경우 두 정점을 연결한다.
   * 최소 신장 트리는 사이클이 없으므로 사이클이 생기지 않도록 하는 과정
4. 탐욕 알고리즘을 기초로 눈 앞의 최소 비용을 선택하여, 결과적으로 최적으 솔루션을 찾음

### 5. Union-Find Algorithm

* Kruskal's Algorithm을 구현 할 때 노드의 순환이 일어나는지 검사하기 위해 사용
* Disjoint Set을 표현할 때 사용하는 알고리즘으로 트리 구조를 활용
* 노드들 중 연결된 노드를 찾거나, 노드들을 서로 연결할 때(Union) 사용
* Disjoint Set이란
  * 서로 중복되지 않는 부분 집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조
  * 공통 원소가  없는 (서로소) 상호 베타적인 부분 집합들로 나눠진 원소들에 대한 자료구조를 의마함
  * Disjoint Set = 서로소 집합 자료구조

1. 초기화 
   1. n 개의 원소가 개별 집합으로 이루어지도록 초기화

2. Union
   1. 두 개별 집합을 하나의 집학으로 합침, 두 트리를 하나의 트리로 만듬

3. Find
   1. 여러 노드가 존재할 때, 두 개의 노드를 선택해서, 현재 두 노드가 서로 같은 그래프에 속하는지 판별하기 위해, 각 그룹의 최상단 원소를 확인
   2. 같은 집합안의 트리에서 루트노드 확인을 통해 알아볼 수 있음 -> 두개의 노드가 연결되어 있고 루트노드가 같으면 순환이 생김

**"Union-Find 알고리즘의 고려할 점"**

* Union 순서에 따라서, 최악의 경우 Linked List과 같은 형태가 되어 시간복잡도가 높아짐
* Union-By-Rank / Path Compression 기법을 통해 극복함

**1. Union-By-Rank**
* 각 트리에 대해 높이 (Rank) 를 기억한다.
* Union 시에 두 트리의 높이가 다르면, 높이가 작은 트리를 높이가 큰 트리에 붙인다.
* 높이가 큰 트리의 루트 노드가 합친 집합의 루트 노드가 되게한다.
* 높이가 h - 1인 두개의 트리를 합칠 때는 한 쪽의 트리 높이를 1 증가시키고 다른 쪽의 트리를 해당트리에 붙힌다.
* 초기화 시, 모든 원소의 높이가 0 인 개별 집합인 상태에서, 하나씩 원소를 합칠 경우
  * 높이가 h 인 트리가 만들어지려면, 높이가 h-1 인 두개의 트리가 합쳐져야 함
  * 높이가 h-1 인 트리를 만들기 위해 최소 n 개의 원소가 필요하다면, 높이가 h 인 트리가 만들어 지기 위해서 최소 2n 개의 원소가 필요함
  * 따라서 시간 복잡도는 O (logN) 으로 낮출 수 있음


**2. Path Compression**
* Find를 실행한 노드에서 거쳐간 노드를 루트에 다이렉트로 연결하는 기법
* Find를 실행한 노드는 이후부터는 루트 노드를 한번에 알 수 있음
* 좀더 찾아보기 !!!

### 6. 프림 알고리즘(Prim's Algorithm)
* 대표적인 최소 신장 트리 알고리즘
* 프림 알고리즘
  * 시작 정점을 선택한 후, 정점에 인접한 간선중 최소 간선으로 연결된 정점을 선택하고, 해당 정점에서 다시 최소 간선으로 연결된 정점을 선택하는 방식으로 최소 신장 트리를 확장해가는 방식
* Kruskal's Algorithm 과 Prim's Algorithm의 차이
  * 탐욕 알고리즘을 기초로 하여 적용 ( 최소 비용을 선택하여, 결과적으로 최적의 솔루션을 찾음 )
  * Krukal's Algorithm은 가장 가중치가 작은 간선부터 선택하여 MST를 구함

1. '임의의' 시작 노드를 선정하고 간선에 가중치가 작은 쪽으로 노드를 연결 
2. 다음 노드에서 연결될 수 있는 간선 중에서 가장 작은 가중치를 가진 간선을 연결
3. 계속 반복 하되 간선간의 순환을 만들지 않게 간선을 연결
   - 어떻게 구현 할까? -> 해당 간선에 연결된 인접 정점이 연결된 노드집합에 포함된다면 Skip
4. 추출한 간선은 간선 리스트에서 제거
5. 간선 리스트에 더 이상의 간선이 없을 때 까지 반복

Tip
- 간선 리스트에서 최소 가중치를 가지는 -> 최소힙 -> (Java) PriorityQueue 를 사용하여 구현 !!!
- 찾는 키에 대한 값이 없을 때, 디폴트 반환
```java
graph.getOrDefault("Key", new ArrayList<>());
```
<br><br>

```java
public class Main{
    public static void main(String[] args){
        Main main = new Main();
        main.func();
    }
    public void func(){
        HashMap<String, ArrayList<PrimEdge>> graph = new HashMap<>();
        graph.put("A", new ArrayList<PrimEdge>());
        graph.put("B", new ArrayList<PrimEdge>());
        System.out.println("Q: Does 'B' have any key? // A: " + graph.containsKey("B"));

        graph.getOrDefault("C", new ArrayList<>());
    }
}
```
### 7. 개선된 프림 알고리즘(Advanced Prim's Algorithm)
